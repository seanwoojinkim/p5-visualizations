<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Painterly Water Background</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a2332;
            font-family: 'Courier New', monospace;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.75);
            padding: 20px;
            border-radius: 8px;
            color: #fff;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #88ccff;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group select {
            width: 100%;
            padding: 5px;
            background: #2a3342;
            color: #fff;
            border: 1px solid #4a5362;
            border-radius: 4px;
        }
        .value-display {
            font-size: 12px;
            color: #aaa;
            margin-top: 3px;
        }
        h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #88ccff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.75);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(10px);
        }
        button {
            width: 100%;
            padding: 10px;
            background: #2a7db8;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 1px;
            margin-top: 10px;
        }
        button:hover {
            background: #3a8dc8;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="controls">
        <h3>Water Controls</h3>

        <div class="control-group">
            <label>Wave Speed</label>
            <input type="range" id="wave-speed" min="0.1" max="3.0" step="0.1" value="1.0">
            <div class="value-display" id="wave-speed-val">1.0</div>
        </div>

        <div class="control-group">
            <label>Wave Amplitude</label>
            <input type="range" id="wave-amplitude" min="0" max="100" step="5" value="30">
            <div class="value-display" id="wave-amplitude-val">30 px</div>
        </div>

        <div class="control-group">
            <label>Flow Speed</label>
            <input type="range" id="flow-speed" min="0" max="2.0" step="0.1" value="0.5">
            <div class="value-display" id="flow-speed-val">0.5</div>
        </div>

        <div class="control-group">
            <label>Particle Count</label>
            <input type="range" id="particle-count" min="50" max="200" step="10" value="80">
            <div class="value-display" id="particle-count-val">80</div>
        </div>

        <div class="control-group">
            <label>Blend Mode</label>
            <select id="blend-mode">
                <option value="BLEND">BLEND (normal)</option>
                <option value="ADD">ADD (glow)</option>
                <option value="MULTIPLY" selected>MULTIPLY (darken)</option>
                <option value="SCREEN">SCREEN (lighten)</option>
                <option value="LIGHTEN">LIGHTEN</option>
                <option value="DARKEST">DARKEST</option>
            </select>
        </div>

        <button id="regenerate">Regenerate Water</button>
    </div>

    <div class="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Particles: <span id="particle-stats">0</span></div>
        <div>Layers: <span id="layer-stats">0</span></div>
    </div>

    <script>
        // ===== SimplexNoise Implementation =====
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                             [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                             [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                this.p = [];
                for(let i=0; i<256; i++) {
                    this.p[i] = Math.floor(this.seededRandom(seed + i) * 256);
                }
                this.perm = [];
                for(let i=0; i<512; i++) {
                    this.perm[i]=this.p[i & 255];
                }
            }

            seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }

            dot(g, x, y) {
                return g[0]*x + g[1]*y;
            }

            noise(xin, yin) {
                let n0, n1, n2;
                const F2 = 0.5*(Math.sqrt(3.0)-1.0);
                const s = (xin+yin)*F2;
                const i = Math.floor(xin+s);
                const j = Math.floor(yin+s);
                const G2 = (3.0-Math.sqrt(3.0))/6.0;
                const t = (i+j)*G2;
                const X0 = i-t;
                const Y0 = j-t;
                const x0 = xin-X0;
                const y0 = yin-Y0;
                let i1, j1;
                if(x0>y0) {i1=1; j1=0;}
                else {i1=0; j1=1;}
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii+this.perm[jj]] % 12;
                const gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
                const gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
                let t0 = 0.5 - x0*x0-y0*y0;
                if(t0<0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                let t1 = 0.5 - x1*x1-y1*y1;
                if(t1<0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                let t2 = 0.5 - x2*x2-y2*y2;
                if(t2<0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                return 70.0 * (n0 + n1 + n2);
            }
        }

        // ===== WaterBrushstroke Class =====
        // Individual particle that looks like a brushstroke of water
        class WaterBrushstroke {
            constructor(x, y, layer, params = {}) {
                this.x = x;
                this.y = y;
                this.baseY = y; // Original Y position for wave calculation
                this.layer = layer;

                // Visual properties
                this.baseScale = params.baseScale || 600;
                this.scale = this.baseScale;
                this.baseOpacity = params.baseOpacity || 0.3;
                this.opacity = this.baseOpacity;
                this.baseColor = params.baseColor || { r: 100, g: 150, b: 200 };
                this.color = this.generateWaterColor(this.baseColor, layer.depth);

                // Movement properties
                this.flowSpeed = params.flowSpeed || 0.5;
                this.waveSpeed = params.waveSpeed || 1.0;
                this.waveAmplitude = params.waveAmplitude || 30;
                this.wavePhase = Math.random() * Math.PI * 2; // Random starting phase
                this.noiseOffset = Math.random() * 1000;

                // Texture
                this.textureIndex = Math.floor(Math.random() * 5) + 1; // spot-1 to spot-5
            }

            generateWaterColor(baseColor, depth) {
                // Water gets darker/deeper with depth
                // Surface (depth=1): lighter cyan/blue
                // Deep (depth=0): darker blue/teal

                const depthDarken = 0.4 + depth * 0.6; // 0.4 to 1.0
                const variation = 0.8 + Math.random() * 0.4; // 0.8 to 1.2

                // Add some color variation
                const colorShift = (Math.random() - 0.5) * 40;

                return {
                    r: Math.max(0, Math.min(255, (baseColor.r + colorShift) * depthDarken * variation)),
                    g: Math.max(0, Math.min(255, (baseColor.g + colorShift * 0.5) * depthDarken * variation)),
                    b: Math.max(0, Math.min(255, baseColor.b * depthDarken * variation))
                };
            }

            update(noiseEngine, time, params, canvasWidth, canvasHeight) {
                // Very slow drift - sample noise less frequently for performance
                // Only update drift direction every ~30 frames
                if (!this.lastNoiseTime || time - this.lastNoiseTime > 500) {
                    this.lastNoiseTime = time;
                    const noiseX = noiseEngine.noise(this.x * 0.002 + this.noiseOffset, time * 0.0001, 0);
                    const noiseY = noiseEngine.noise(this.x * 0.002 + this.noiseOffset, time * 0.0001, 100);

                    const driftSpeed = (params.flowSpeed || this.flowSpeed) * 0.15;
                    this.driftX = (noiseX - 0.5) * driftSpeed;
                    this.driftY = (noiseY - 0.5) * driftSpeed;
                }

                // Apply cached drift
                this.x += this.driftX || 0;
                this.y += this.driftY || 0;

                // Gentle wrapping to keep particles on screen
                if (this.x < -this.scale) this.x = canvasWidth + this.scale;
                if (this.x > canvasWidth + this.scale) this.x = -this.scale;
                if (this.y < -this.scale) this.y = canvasHeight + this.scale;
                if (this.y > canvasHeight + this.scale) this.y = -this.scale;

                // Keep scale and opacity constant (no pulsing/breathing)
                this.scale = this.baseScale;
                this.opacity = this.baseOpacity;
            }

            display(p5, textureCache) {
                const texture = textureCache[this.textureIndex];
                if (!texture) return;

                p5.push();
                p5.translate(this.x, this.y);

                // Apply color tint
                p5.tint(this.color.r, this.color.g, this.color.b, this.opacity * 255);

                // Draw brushstroke
                p5.imageMode(p5.CENTER);
                p5.image(texture, 0, 0, this.scale, this.scale);

                p5.pop();
            }
        }

        // ===== WaterLayer Class =====
        // A depth layer of water brushstrokes
        class WaterLayer {
            constructor(depth, params = {}) {
                this.depth = depth; // 0 (deep) to 1 (surface)
                this.brushstrokes = [];

                // Depth-based properties
                this.depthScale = 0.5 + (depth * 0.5); // Deep = smaller, surface = larger
                this.depthAlpha = 0.3 + (depth * 0.7); // Deep = more transparent
                this.flowMultiplier = 0.3 + (depth * 0.7); // Surface flows faster

                this.params = params;
            }

            addBrushstroke(brushstroke) {
                brushstroke.baseScale *= this.depthScale;
                brushstroke.scale = brushstroke.baseScale;
                brushstroke.baseOpacity *= this.depthAlpha;
                brushstroke.opacity = brushstroke.baseOpacity;
                this.brushstrokes.push(brushstroke);
            }

            generateBrushstrokes(count, canvasWidth, canvasHeight, baseColor) {
                // Add padding to ensure full coverage at edges
                const padding = 300;
                for (let i = 0; i < count; i++) {
                    const x = -padding + Math.random() * (canvasWidth + padding * 2);
                    const y = -padding + Math.random() * (canvasHeight + padding * 2);

                    const brushstroke = new WaterBrushstroke(x, y, this, {
                        baseScale: 500 + Math.random() * 400,
                        baseOpacity: 0.2 + Math.random() * 0.3,
                        baseColor: baseColor,
                        flowSpeed: 0.5,
                        waveSpeed: 1.0,
                        waveAmplitude: 30
                    });

                    this.addBrushstroke(brushstroke);
                }
            }

            update(noiseEngine, time, params, canvasWidth, canvasHeight) {
                for (const brushstroke of this.brushstrokes) {
                    brushstroke.update(noiseEngine, time, params, canvasWidth, canvasHeight);
                }
            }

            display(p5, textureCache) {
                p5.push();

                // Apply blend mode
                const mode = window.currentBlendMode || 'ADD';
                if (mode === 'ADD') p5.blendMode(p5.ADD);
                else if (mode === 'MULTIPLY') p5.blendMode(p5.MULTIPLY);
                else if (mode === 'SCREEN') p5.blendMode(p5.SCREEN);
                else if (mode === 'LIGHTEN') p5.blendMode(p5.LIGHTEN);
                else if (mode === 'DARKEST') p5.blendMode(p5.DARKEST);
                else p5.blendMode(p5.BLEND);

                for (const brushstroke of this.brushstrokes) {
                    brushstroke.display(p5, textureCache);
                }

                p5.blendMode(p5.BLEND);
                p5.pop();
            }

            clear() {
                this.brushstrokes = [];
            }
        }

        // ===== Main P5.js Sketch =====
        let noiseEngine;
        let waterLayers = [];
        let textureCache = {};
        let startTime;

        // Water color palette - matching water-background.png
        const WATER_COLORS = {
            deep: { r: 30, g: 90, b: 160 },      // Rich deep blue
            mid: { r: 60, g: 140, b: 200 },      // Ocean blue
            surface: { r: 100, g: 180, b: 230 }  // Light cyan-blue
        };

        // Global params
        window.currentBlendMode = 'MULTIPLY';
        window.waterParams = {
            waveSpeed: 1.0,
            waveAmplitude: 30,
            flowSpeed: 0.5,
            particleCount: 80,
            numLayers: 2
        };

        function preload() {
            // Load pre-processed brushstroke textures (already have transparent backgrounds)
            for (let i = 1; i <= 5; i++) {
                loadImage(`assets/brushstrokes/spot-${i}-processed.png`,
                    (img) => {
                        textureCache[i] = img;
                        console.log(`Loaded spot-${i}-processed.png`);
                    },
                    (err) => {
                        console.error(`Failed to load spot-${i}-processed.png:`, err);
                    }
                );
            }
        }

        function setup() {
            const canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('canvas-container');

            noiseEngine = new SimplexNoise(Date.now());
            startTime = millis();

            generateWater();

            // Set up UI listeners
            setupUIListeners();
        }

        function generateWater() {
            // Clear existing layers
            for (const layer of waterLayers) {
                layer.clear();
            }
            waterLayers = [];

            const params = window.waterParams;
            const particlesPerLayer = Math.floor(params.particleCount / params.numLayers);

            // Create depth layers (0 = deep, 1 = surface)
            for (let i = 0; i < params.numLayers; i++) {
                const depth = i / (params.numLayers - 1);
                const layer = new WaterLayer(depth, {});

                // Assign color based on depth
                let baseColor;
                if (depth < 0.33) baseColor = WATER_COLORS.deep;
                else if (depth < 0.66) baseColor = WATER_COLORS.mid;
                else baseColor = WATER_COLORS.surface;

                layer.generateBrushstrokes(particlesPerLayer, width, height, baseColor);
                waterLayers.push(layer);
            }

            console.log(`Generated ${waterLayers.length} layers with ~${particlesPerLayer} particles each`);
        }

        function draw() {
            // Light paper-like background (like watercolor on paper)
            background(245, 248, 250); // Soft off-white

            const time = millis() - startTime;
            const params = window.waterParams;

            // Update and display all layers (back to front)
            for (const layer of waterLayers) {
                layer.update(noiseEngine, time, params, width, height);
                layer.display(window, textureCache);
            }

            // Update stats
            updateStats();
        }

        function updateStats() {
            document.getElementById('fps').textContent = Math.round(frameRate());
            const totalParticles = waterLayers.reduce((sum, layer) => sum + layer.brushstrokes.length, 0);
            document.getElementById('particle-stats').textContent = totalParticles;
            document.getElementById('layer-stats').textContent = waterLayers.length;
        }

        function setupUIListeners() {
            // Wave Speed
            document.getElementById('wave-speed').addEventListener('input', (e) => {
                window.waterParams.waveSpeed = parseFloat(e.target.value);
                document.getElementById('wave-speed-val').textContent = e.target.value;
            });

            // Wave Amplitude
            document.getElementById('wave-amplitude').addEventListener('input', (e) => {
                window.waterParams.waveAmplitude = parseFloat(e.target.value);
                document.getElementById('wave-amplitude-val').textContent = e.target.value + ' px';
            });

            // Flow Speed
            document.getElementById('flow-speed').addEventListener('input', (e) => {
                window.waterParams.flowSpeed = parseFloat(e.target.value);
                document.getElementById('flow-speed-val').textContent = e.target.value;
            });

            // Particle Count
            document.getElementById('particle-count').addEventListener('input', (e) => {
                window.waterParams.particleCount = parseInt(e.target.value);
                document.getElementById('particle-count-val').textContent = e.target.value;
            });

            // Blend Mode
            document.getElementById('blend-mode').addEventListener('change', (e) => {
                window.currentBlendMode = e.target.value;
                console.log('Blend mode changed to:', window.currentBlendMode);
            });

            // Regenerate button
            document.getElementById('regenerate').addEventListener('click', () => {
                generateWater();
            });
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            generateWater();
        }
    </script>
</body>
</html>
